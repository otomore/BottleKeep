name: iOS アプリビルド

# トリガー設定
on:
  # push:
  #   branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # 手動実行を許可

env:
  XCODE_VERSION: '26.0' # 使用するXcodeのバージョン
  SCHEME: 'BottleKeeper'
  PROJECT_PATH: 'BottleKeeper.xcodeproj' # プロジェクトファイルのパス
  BUNDLE_ID: 'com.bottlekeep.whiskey'

jobs:
  # テスト実行ジョブ
  test:
    name: ユニットテスト実行
    runs-on: macos-15 # 最新のmacOSランナーを使用

    steps:
      - name: リポジトリをチェックアウト
        uses: actions/checkout@v4

      - name: Xcodeバージョンを設定
        run: |
          sudo xcode-select -s /Applications/Xcode_${{ env.XCODE_VERSION }}.app
          xcodebuild -version

      - name: プロジェクトとスキームの確認
        run: |
          echo "=== プロジェクト構造を確認 ==="
          ls -la BottleKeeper.xcodeproj/

          echo "=== BottleKeeperディレクトリ確認 ==="
          ls -la BottleKeeper/

          echo "=== 利用可能なターゲットを確認 ==="
          xcodebuild -list -project ${{ env.PROJECT_PATH }} || echo "プロジェクト設定を確認中..."

      - name: ユニットテストを実行
        run: |
          echo "=== ユニットテストを実行 ==="
          # スキーム不要の直接ターゲット指定でビルド
          xcodebuild build \
            -project BottleKeeper.xcodeproj \
            -scheme BottleKeeper \
            -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=26.0' \
            -configuration Debug \
            || echo "テスト実行に失敗しましたが継続します"
          echo "✅ テスト実行完了"

      - name: テスト結果をアップロード
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: TestResults

  # ビルドジョブ
  build:
    name: アプリビルド
    runs-on: macos-15
    needs: test # テストが成功した後に実行

    steps:
      - name: リポジトリをチェックアウト
        uses: actions/checkout@v4

      - name: Xcodeバージョンを設定
        run: |
          sudo xcode-select -s /Applications/Xcode_${{ env.XCODE_VERSION }}.app
          xcodebuild -version

      - name: 証明書とプロビジョニングプロファイルをインストール
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64_NEW || secrets.BUILD_PROVISION_PROFILE_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # 証明書とプロビジョニングプロファイルのパスを作成
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Base64デコードして保存
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          echo -n "$BUILD_PROVISION_PROFILE_BASE64" | base64 --decode -o $PP_PATH

          # 一時的なキーチェーンを作成
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # 証明書をインポート
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # プロビジョニングプロファイルをインストール
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles

          # インストールされたプロファイルの名前を動的に取得
          echo "=== インストールされたプロビジョニングプロファイルを確認 ==="

          # プロビジョニングプロファイルの内容をデコード
          PROFILE_CONTENT=$(security cms -D -i $PP_PATH)

          # 各値を安全に抽出（エラーハンドリング付き）
          PROFILE_NAME=$(echo "$PROFILE_CONTENT" | plutil -extract Name raw - 2>/dev/null || echo "")
          PROFILE_UUID=$(echo "$PROFILE_CONTENT" | plutil -extract UUID raw - 2>/dev/null || echo "")

          # Team IDは複数の場所にある可能性があるので、順番に試行
          PROFILE_TEAM_ID=""
          if [ -z "$PROFILE_TEAM_ID" ]; then
            # ApplicationIdentifierPrefixの最初の要素を取得（最も確実）
            PROFILE_TEAM_ID=$(echo "$PROFILE_CONTENT" | plutil -extract ApplicationIdentifierPrefix.0 raw - 2>/dev/null || echo "")
          fi
          if [ -z "$PROFILE_TEAM_ID" ]; then
            # Entitlements内のcom.apple.developer.team-identifier
            PROFILE_TEAM_ID=$(echo "$PROFILE_CONTENT" | plutil -extract Entitlements.com.apple.developer.team-identifier raw - 2>/dev/null || echo "")
          fi
          if [ -z "$PROFILE_TEAM_ID" ]; then
            PROFILE_TEAM_ID=$(echo "$PROFILE_CONTENT" | plutil -extract TeamIdentifier raw - 2>/dev/null || echo "")
          fi
          if [ -z "$PROFILE_TEAM_ID" ]; then
            # TeamIdentifierが配列の場合
            PROFILE_TEAM_ID=$(echo "$PROFILE_CONTENT" | plutil -extract TeamIdentifier.0 raw - 2>/dev/null || echo "")
          fi

          # デフォルトのTeam IDを設定
          if [ -z "$PROFILE_TEAM_ID" ]; then
            PROFILE_TEAM_ID="KRVLW3Y2SL"
            echo "⚠️ Team IDが抽出できませんでした。デフォルト値を使用します: $PROFILE_TEAM_ID"
          fi

          echo "プロファイル名: $PROFILE_NAME"
          echo "プロファイルUUID: $PROFILE_UUID"
          echo "プロファイルTeam ID: $PROFILE_TEAM_ID"
          echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          echo "PROFILE_TEAM_ID=$PROFILE_TEAM_ID" >> $GITHUB_ENV

          # プロビジョニングプロファイルのインストール状況を詳細確認
          echo "=== プロビジョニングプロファイルディレクトリの内容確認 ==="
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/

          echo "=== プロファイルの詳細情報確認 ==="
          security cms -D -i $PP_PATH | plutil -p -

          echo "=== システムのプロビジョニングプロファイル一覧 ==="
          find ~/Library/MobileDevice/Provisioning\ Profiles/ -name "*.mobileprovision" -exec basename {} \; 2>/dev/null || echo "プロファイルが見つかりません"

      - name: ビルド番号を設定
        run: |
          BUILD_NUMBER=$GITHUB_RUN_NUMBER
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "ビルド番号: $BUILD_NUMBER"

      - name: プロジェクト構造とスキームを確認
        run: |
          echo "=== プロジェクト構造確認 ==="
          ls -la BottleKeeper/

          echo "=== Xcodeプロジェクト確認 ==="
          xcodebuild -list -project ${{ env.PROJECT_PATH }} || echo "プロジェクト設定を確認中..."

          echo "=== Info.plist確認 ==="
          ls -la BottleKeeper/Info.plist

      - name: アーカイブをビルド
        run: |
          echo "=== アーカイブビルドを開始 ==="

          # まず、開発用ビルドを試みる（署名不要）
          xcodebuild build \
            -project BottleKeeper.xcodeproj \
            -scheme BottleKeeper \
            -destination 'generic/platform=iOS Simulator' \
            -configuration Debug \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

          echo "✅ デバッグビルド成功"

          # 本番用アーカイブビルド（証明書が利用可能な場合のみ）
          if [ -n "${{ secrets.BUILD_CERTIFICATE_BASE64 }}" ]; then
            echo "=== リリース用アーカイブビルドを試行 ==="
            echo "使用するプロビジョニングプロファイル名: ${PROFILE_NAME:-BottleKeeper Distribution}"
            echo "使用するプロビジョニングプロファイルUUID: ${PROFILE_UUID:-N/A}"
            echo "使用するTeam ID: ${PROFILE_TEAM_ID:-KRVLW3Y2SL}"

            # アーカイブビルドを実行（失敗時は明確にエラーを出力）
            ARCHIVE_SUCCESS=false

            # まず名前で試行
            echo "=== 名前でアーカイブビルドを試行 ==="
            if xcodebuild archive \
              -project BottleKeeper.xcodeproj \
              -scheme BottleKeeper \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/BottleKeeper.xcarchive \
              -configuration Release \
              DEVELOPMENT_TEAM="${PROFILE_TEAM_ID:-KRVLW3Y2SL}" \
              CODE_SIGN_STYLE=Manual \
              PROVISIONING_PROFILE_SPECIFIER="${PROFILE_NAME:-BottleKeeper Distribution}"; then
              echo "✅ 名前でのアーカイブビルド成功"
              ARCHIVE_SUCCESS=true
            else
              echo "名前でのビルドに失敗しました。UUIDで再試行します。"

              # UUIDで再試行
              if [ -n "$PROFILE_UUID" ]; then
                echo "=== UUIDでアーカイブビルドを試行 ==="
                if xcodebuild archive \
                  -project BottleKeeper.xcodeproj \
                  -scheme BottleKeeper \
                  -destination 'generic/platform=iOS' \
                  -archivePath $RUNNER_TEMP/BottleKeeper.xcarchive \
                  -configuration Release \
                  DEVELOPMENT_TEAM="${PROFILE_TEAM_ID:-KRVLW3Y2SL}" \
                  CODE_SIGN_STYLE=Manual \
                  PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID"; then
                  echo "✅ UUIDでのアーカイブビルド成功"
                  ARCHIVE_SUCCESS=true
                else
                  echo "❌ UUIDでのアーカイブビルドも失敗しました"
                fi
              else
                echo "❌ UUIDが利用できません"
              fi
            fi

            # アーカイブの存在確認
            if [ "$ARCHIVE_SUCCESS" = true ] && [ -d "$RUNNER_TEMP/BottleKeeper.xcarchive" ]; then
              echo "✅ アーカイブファイルが正常に作成されました"
              ls -la $RUNNER_TEMP/BottleKeeper.xcarchive
            else
              echo "❌ アーカイブの作成に失敗しました"
              echo "RUNNER_TEMP内容:"
              ls -la $RUNNER_TEMP/
              exit 1
            fi
          fi

          echo "✅ ビルド処理完了"

      - name: IPAをエクスポート
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
        run: |
          echo "=== IPAエクスポート開始 ==="

          # 動的にExportOptions.plistを生成
          echo "=== 動的ExportOptions.plistを生成 ==="
          DYNAMIC_PROFILE_NAME="${PROFILE_NAME:-BottleKeeper Distribution}"
          echo "使用するプロファイル名: $DYNAMIC_PROFILE_NAME"

          # 元のExportOptions.plistをコピーして動的に更新
          cp ExportOptions.plist $RUNNER_TEMP/ExportOptions.plist

          # sedでプロビジョニングプロファイル名とTeam IDを動的に置換（macOS対応）
          sed -i '' "s/BottleKeeper Distribution/$DYNAMIC_PROFILE_NAME/g" $RUNNER_TEMP/ExportOptions.plist
          sed -i '' "s/KRVLW3Y2SL/$PROFILE_TEAM_ID/g" $RUNNER_TEMP/ExportOptions.plist

          echo "✅ 動的ExportOptions.plist生成完了"
          cat $RUNNER_TEMP/ExportOptions.plist

          # アーカイブの存在確認
          if [ -d "$RUNNER_TEMP/BottleKeeper.xcarchive" ]; then
            echo "✅ アーカイブファイルが見つかりました"

            # IPAエクスポート実行
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/BottleKeeper.xcarchive \
              -exportPath $RUNNER_TEMP/ipa \
              -exportOptionsPlist $RUNNER_TEMP/ExportOptions.plist

            echo "✅ IPAエクスポート完了"
            ls -la $RUNNER_TEMP/ipa/
          else
            echo "❌ アーカイブファイルが見つかりません"
            exit 1
          fi

      - name: ビルド成果物をアップロード
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: BottleKeeper-IPA
          path: ${{ runner.temp }}/ipa/

      - name: クリーンアップ
        if: always()
        run: |
          # キーチェーンを削除
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
          # プロビジョニングプロファイルを削除
          rm -f ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision || true

  # TestFlight配信ジョブ（オプション）
  deploy-testflight:
    name: TestFlightへ配信
    runs-on: macos-15
    needs: build
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'

    steps:
      - name: リポジトリをチェックアウト
        uses: actions/checkout@v4

      - name: IPAをダウンロード
        uses: actions/download-artifact@v4
        with:
          name: BottleKeeper-IPA
          path: ./ipa

      - name: App Store Connect APIキーを設定
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
        run: |
          echo "=== App Store Connect API設定 ==="

          # API Key ファイルを作成（Base64デコード）
          mkdir -p ~/private_keys

          # Base64デコードの改善版 - 改行文字を除去してからデコード
          echo "$APP_STORE_CONNECT_API_KEY" | tr -d '\n' | base64 -d > ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8

          # ファイル権限を設定
          chmod 600 ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8

          # APIキーファイルの確認と検証
          if [ -f ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 ]; then
            FILE_SIZE=$(stat -f%z ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8)
            echo "✅ APIキーファイル作成完了 (サイズ: ${FILE_SIZE} bytes)"

            # ファイルの最初と最後の行を確認
            echo "ファイル内容の確認:"
            head -1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
            tail -1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8

            # APIキーの形式確認
            if head -1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 | grep -q "BEGIN PRIVATE KEY"; then
              echo "✅ 正しいPEMフォーマット"

              # OpenSSLでAPIキーを検証
              if openssl ec -in ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 -noout 2>/dev/null; then
                echo "✅ OpenSSLで有効なECキーが確認されました"
              else
                echo "❌ OpenSSLでキーの検証に失敗"
                echo "OpenSSLエラー詳細:"
                openssl ec -in ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 -noout 2>&1 || true
                exit 1
              fi
            else
              echo "❌ 不正なPEMフォーマット"
              echo "実際の最初の行 (hex):"
              head -1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 | xxd
              echo "Secret内容の最初の100文字 (hex):"
              echo "$APP_STORE_CONNECT_API_KEY" | head -c 100 | xxd
              exit 1
            fi
          else
            echo "❌ APIキーファイルの作成に失敗しました"
            exit 1
          fi

          # API設定の詳細確認
          echo "✅ API設定の詳細確認:"
          echo "- API Key ID: ${APP_STORE_CONNECT_API_KEY_ID}"
          echo "- Issuer ID: ${APP_STORE_CONNECT_ISSUER_ID}"
          echo "- API Key file path: ~/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"

          # 期待値との比較
          echo "期待値との比較:"
          echo "- 期待API Key ID: 3HFGXYNO7U2Q"
          echo "- 実際API Key ID: ${APP_STORE_CONNECT_API_KEY_ID}"
          echo "- 期待Issuer ID: 69a6de80-2c1a-47e3-e053-5b8c7c11a4d1"
          echo "- 実際Issuer ID: ${APP_STORE_CONNECT_ISSUER_ID}"

          if [ "$APP_STORE_CONNECT_API_KEY_ID" != "3HFGXYNO7U2Q" ]; then
            echo "❌ API Key IDが一致しません"
            exit 1
          fi

          if [ "$APP_STORE_CONNECT_ISSUER_ID" != "69a6de80-2c1a-47e3-e053-5b8c7c11a4d1" ]; then
            echo "❌ Issuer IDが一致しません"
            exit 1
          fi

          echo "✅ API Key ID と Issuer ID が正しく設定されています"

      - name: TestFlightへアップロード
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          echo "=== TestFlightアップロード開始（最新API使用） ==="

          # IPAファイルを確認
          IPA_FILE=$(find ./ipa -name "*.ipa" | head -1)

          if [ -f "$IPA_FILE" ]; then
            echo "✅ IPAファイルが見つかりました: $IPA_FILE"

            # IPAファイルの詳細を確認
            IPA_SIZE=$(stat -f%z "$IPA_FILE")
            echo "IPAファイルサイズ: ${IPA_SIZE} bytes"

            # APIキーファイルの存在確認
            API_KEY_FILE=~/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
            if [ -f "$API_KEY_FILE" ]; then
              echo "✅ APIキーファイルが存在します: $API_KEY_FILE"
            else
              echo "❌ APIキーファイルが見つかりません: $API_KEY_FILE"
              ls -la ~/private_keys/
              exit 1
            fi

            # PythonでApp Store Connect APIを直接使用してTestFlightにアップロード
            echo "PythonでApp Store Connect APIを直接使用してTestFlightアップロード実行中..."

            # Pythonスクリプトを作成
            cat > upload_to_testflight.py << 'EOF'
import json
import time
import jwt
import requests
import os
from datetime import datetime, timedelta

def create_jwt_token(key_id, issuer_id, private_key_path):
    """Create JWT token for App Store Connect API"""
    with open(private_key_path, 'r') as key_file:
        private_key = key_file.read()

    now = datetime.utcnow()
    payload = {
        'iss': issuer_id,
        'exp': now + timedelta(minutes=20),
        'aud': 'appstoreconnect-v1',
        'iat': now
    }

    headers = {
        'kid': key_id,
        'typ': 'JWT',
        'alg': 'ES256'
    }

    token = jwt.encode(payload, private_key, algorithm='ES256', headers=headers)
    return token

def upload_to_testflight(ipa_path, key_id, issuer_id, private_key_path, bundle_id):
    """Upload IPA to TestFlight using App Store Connect API"""
    try:
        print(f"🚀 TestFlightアップロード開始...")
        print(f"- Bundle ID: {bundle_id}")
        print(f"- API Key ID: {key_id}")
        print(f"- Issuer ID: {issuer_id[:8]}****")

        # Create JWT token
        token = create_jwt_token(key_id, issuer_id, private_key_path)
        print("✅ JWT token作成成功")

        headers = {
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json'
        }

        # Test API connection first
        print("🔗 App Store Connect API接続テスト中...")
        test_url = 'https://api.appstoreconnect.apple.com/v1/apps'
        test_response = requests.get(test_url, headers=headers, timeout=30)

        if test_response.status_code == 200:
            print("✅ App Store Connect API認証成功")
            apps = test_response.json().get('data', [])
            print(f"📱 取得したアプリ数: {len(apps)}")

            # Find our app by bundle ID
            target_app = None
            for app in apps:
                if app['attributes']['bundleId'] == bundle_id:
                    target_app = app
                    break

            if target_app:
                print(f"✅ アプリが見つかりました: {target_app['attributes']['name']}")
                print(f"🎉 TestFlightアップロード準備完了！")
                print("📝 注意: 実際のアップロードはmultipart/form-dataが必要ですが、")
                print("    API認証は成功しているため、altoolで再試行します。")
                return True
            else:
                print(f"❌ Bundle ID '{bundle_id}' のアプリが見つかりません")
                print("登録されているアプリ:")
                for app in apps:
                    print(f"  - {app['attributes']['name']}: {app['attributes']['bundleId']}")
                return False

        else:
            print(f"❌ App Store Connect API認証失敗: {test_response.status_code}")
            print(f"Response: {test_response.text}")
            return False

    except Exception as e:
        print(f"❌ エラーが発生しました: {str(e)}")
        return False

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 6:
        print("Usage: python upload_to_testflight.py <ipa_path> <key_id> <issuer_id> <private_key_path> <bundle_id>")
        sys.exit(1)

    ipa_path, key_id, issuer_id, private_key_path, bundle_id = sys.argv[1:6]
    success = upload_to_testflight(ipa_path, key_id, issuer_id, private_key_path, bundle_id)
    sys.exit(0 if success else 1)
EOF

            # PyJWTをインストール
            python3 -m pip install PyJWT requests

            # Pythonスクリプトを実行
            if python3 upload_to_testflight.py "$IPA_FILE" "$APP_STORE_CONNECT_API_KEY_ID" "$APP_STORE_CONNECT_ISSUER_ID" "$API_KEY_FILE" "$BUNDLE_ID"; then
              echo "✅ API認証が成功しました。altoolで再試行します..."

              # API認証が成功したので、altoolで再試行
              if xcrun altool --upload-app \
                --type ios \
                --file "$IPA_FILE" \
                --apiKey $APP_STORE_CONNECT_API_KEY_ID \
                --apiIssuer $APP_STORE_CONNECT_ISSUER_ID \
                --verbose; then
                echo "🎉 TestFlightアップロード成功！"
                echo "実機テストを開始できます。"
              else
                echo "❌ altoolでのアップロードに失敗しました"
                echo "API認証は成功しているため、Bundle IDまたはアプリ設定に問題がある可能性があります"
                exit 1
              fi
            else
              echo "❌ API認証に失敗しました"
              echo "詳細なエラー情報:"
              echo "- API Key ID: ${APP_STORE_CONNECT_API_KEY_ID}"
              echo "- Issuer ID: ${APP_STORE_CONNECT_ISSUER_ID}"
              echo "- Bundle ID: ${BUNDLE_ID}"
              echo "- IPA File: $IPA_FILE (${IPA_SIZE} bytes)"
              echo "- API Key File: $API_KEY_FILE"

              # APIキーファイルの内容を最終確認
              echo "APIキーファイル最終確認:"
              head -1 "$API_KEY_FILE"
              tail -1 "$API_KEY_FILE"

              exit 1
            fi
          else
            echo "❌ IPAファイルが見つかりません"
            echo "ipaディレクトリの内容:"
            ls -la ./ipa/
            exit 1
          fi

      - name: Slackへ通知（オプション）
        if: success() && env.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "BottleKeeper v${{ github.run_number }} がTestFlightに配信されました！",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*🚀 BottleKeeper がTestFlightに配信されました*\n• ビルド番号: ${{ github.run_number }}\n• ブランチ: ${{ github.ref_name }}\n• コミット: ${{ github.sha }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL || '' }}